Description: Add GNU/kFreeBSD support
Author: Viktor Vasilev
Author: Robert Millan <rmh@aybabtu.com>
Author: Colin Watson <cjwatson@debian.org>
Bug-Debian: http://bugs.debian.org/363381
Forwarded: no
Last-Update: 2010-03-25

Index: b/configure.ac
===================================================================
--- a/configure.ac
+++ b/configure.ac
@@ -60,6 +60,8 @@
 	linux*) OS=linux ;;
 	gnu*)	OS=gnu ;;
 	beos*)	OS=beos ;;
+	freebsd* | kfreebsd*-gnu)
+			OS=freebsd ;;
 	*)	AC_MSG_ERROR([Unknown or unsupported OS "$host_os".  Only "linux", "gnu" and "beos" are supported in this version of GNU Parted.]) ;;
 esac
 AC_SUBST([OS])
@@ -280,6 +282,7 @@
 	#include <sys/types.h>
 	#include <unistd.h>
 ])
+AC_CHECK_TYPE([loff_t], [long long])
 
 AM_ENABLE_SHARED
 if test "$OS" = linux -a $ac_cv_sizeof_off_t -lt 8; then
@@ -498,6 +501,20 @@
 	OS_LIBS="$OS_LIBS -lsocket"
 fi
 
+dnl FreeBSD (and GNU/kFreeBSD):
+if test "$OS" = freebsd; then
+dnl    CFLAGS="$CFLAGS -D_GNU_SOURCE=1"
+
+dnl libgeom
+	AC_CHECK_LIB([geom], [gctl_get_handle],
+		OS_LIBS="$OS_LIBS -lgeom",
+		AC_MSG_ERROR(
+[GNU Parted requires libgeom when running on FreeBSD or derivative systems.]
+		)
+		exit
+	)
+fi
+
 AC_SUBST([OS_LIBS])
 
 dnl One day, gettext might support libtool...
@@ -517,7 +534,7 @@
         http://web.mit.edu/tytso/www/linux/e2fsprogs.html])]
 )
 
-AC_CHECK_HEADERS([getopt.h])
+AC_CHECK_HEADERS([getopt.h endian.h sys/endian.h])
 
 dnl required for libparted/llseek.c  (TODO: make linux-x86 only)
 if test "$OS" = linux; then
@@ -576,7 +593,9 @@
 AC_C_RESTRICT
 
 dnl Checks for library functions.
-AC_CHECK_FUNCS([sigaction])
+if test "$OS" != freebsd; then
+	AC_CHECK_FUNCS([sigaction])
+fi
 AC_CHECK_FUNCS([getuid])
 
 dnl NOTE: We need to remove the gl_cv_ignore_unused_libraries flag if we
Index: b/configure
===================================================================
--- a/configure
+++ b/configure
@@ -3727,6 +3727,8 @@
 	linux*) OS=linux ;;
 	gnu*)	OS=gnu ;;
 	beos*)	OS=beos ;;
+	freebsd* | kfreebsd*-gnu)
+			OS=freebsd ;;
 	*)	as_fn_error "Unknown or unsupported OS \"$host_os\".  Only \"linux\", \"gnu\" and \"beos\" are supported in this version of GNU Parted." "$LINENO" 5 ;;
 esac
 
@@ -20995,6 +20997,17 @@
 _ACEOF
 
 
+ac_fn_c_check_type "$LINENO" "loff_t" "ac_cv_type_loff_t" "$ac_includes_default"
+if test "x$ac_cv_type_loff_t" = x""yes; then :
+
+else
+
+cat >>confdefs.h <<_ACEOF
+#define loff_t long long
+_ACEOF
+
+fi
+
 
 # Check whether --enable-shared was given.
 if test "${enable_shared+set}" = set; then :
@@ -30102,6 +30115,55 @@
 			OS_LIBS="$OS_LIBS -lsocket"
 fi
 
+if test "$OS" = freebsd; then
+
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for gctl_get_handle in -lgeom" >&5
+$as_echo_n "checking for gctl_get_handle in -lgeom... " >&6; }
+if test "${ac_cv_lib_geom_gctl_get_handle+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgeom  $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char gctl_get_handle ();
+int
+main ()
+{
+return gctl_get_handle ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_geom_gctl_get_handle=yes
+else
+  ac_cv_lib_geom_gctl_get_handle=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_geom_gctl_get_handle" >&5
+$as_echo "$ac_cv_lib_geom_gctl_get_handle" >&6; }
+if test "x$ac_cv_lib_geom_gctl_get_handle" = x""yes; then :
+  OS_LIBS="$OS_LIBS -lgeom"
+else
+  as_fn_error "GNU Parted requires libgeom when running on FreeBSD or derivative systems.
+		" "$LINENO" 5
+		exit
+
+fi
+
+fi
+
 
 
 
@@ -30121,12 +30183,14 @@
 
 
 
-for ac_header in getopt.h
+for ac_header in getopt.h endian.h sys/endian.h
 do :
-  ac_fn_c_check_header_mongrel "$LINENO" "getopt.h" "ac_cv_header_getopt_h" "$ac_includes_default"
-if test "x$ac_cv_header_getopt_h" = x""yes; then :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+eval as_val=\$$as_ac_Header
+   if test "x$as_val" = x""yes; then :
   cat >>confdefs.h <<_ACEOF
-#define HAVE_GETOPT_H 1
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
 
 fi
@@ -30974,7 +31038,8 @@
  esac
 
 
-for ac_func in sigaction
+if test "$OS" != freebsd; then
+	for ac_func in sigaction
 do :
   ac_fn_c_check_func "$LINENO" "sigaction" "ac_cv_func_sigaction"
 if test "x$ac_cv_func_sigaction" = x""yes; then :
@@ -30985,6 +31050,7 @@
 fi
 done
 
+fi
 for ac_func in getuid
 do :
   ac_fn_c_check_func "$LINENO" "getuid" "ac_cv_func_getuid"
Index: b/lib/config.h.in
===================================================================
--- a/lib/config.h.in
+++ b/lib/config.h.in
@@ -226,6 +226,9 @@
 /* Define to 1 if you have the `dup2' function. */
 #undef HAVE_DUP2
 
+/* Define to 1 if you have the <endian.h> header file. */
+#undef HAVE_ENDIAN_H
+
 /* Define if you have the declaration of environ. */
 #undef HAVE_ENVIRON_DECL
 
@@ -784,6 +787,9 @@
 /* Define to 1 if you have the <sys/bitypes.h> header file. */
 #undef HAVE_SYS_BITYPES_H
 
+/* Define to 1 if you have the <sys/endian.h> header file. */
+#undef HAVE_SYS_ENDIAN_H
+
 /* Define to 1 if you have the <sys/inttypes.h> header file. */
 #undef HAVE_SYS_INTTYPES_H
 
@@ -1126,6 +1132,9 @@
 /* Define to rpl_localtime if the replacement function should be used. */
 #undef localtime
 
+/* Define to `long long' if <sys/types.h> does not define. */
+#undef loff_t
+
 /* Define to rpl_malloc if the replacement function should be used. */
 #undef malloc
 
Index: b/libparted/Makefile.am
===================================================================
--- a/libparted/Makefile.am
+++ b/libparted/Makefile.am
@@ -49,7 +49,8 @@
 EXTRA_libparted_la_SOURCES    = arch/linux.c	\
 				arch/linux.h	\
 				arch/gnu.c	\
-				arch/beos.c
+				arch/beos.c	\
+				arch/freebsd.c
 
 libparted_la_LIBADD =	\
   fs/libfs.la		\
Index: b/libparted/Makefile.in
===================================================================
--- a/libparted/Makefile.in
+++ b/libparted/Makefile.in
@@ -897,7 +897,8 @@
 EXTRA_libparted_la_SOURCES = arch/linux.c	\
 				arch/linux.h	\
 				arch/gnu.c	\
-				arch/beos.c
+				arch/beos.c	\
+				arch/freebsd.c
 
 libparted_la_LIBADD = \
   fs/libfs.la		\
@@ -996,6 +997,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/disk.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/exception.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/filesys.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/freebsd.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/geom.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gnu.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libparted.Plo@am__quote@
@@ -1074,6 +1076,13 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o beos.lo `test -f 'arch/beos.c' || echo '$(srcdir)/'`arch/beos.c
 
+freebsd.lo: arch/freebsd.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT freebsd.lo -MD -MP -MF $(DEPDIR)/freebsd.Tpo -c -o freebsd.lo `test -f 'arch/freebsd.c' || echo '$(srcdir)/'`arch/freebsd.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/freebsd.Tpo $(DEPDIR)/freebsd.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='arch/freebsd.c' object='freebsd.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o freebsd.lo `test -f 'arch/freebsd.c' || echo '$(srcdir)/'`arch/freebsd.c
+
 mostlyclean-libtool:
 	-rm -f *.lo
 
Index: b/libparted/arch/freebsd.c
===================================================================
--- /dev/null
+++ b/libparted/arch/freebsd.c
@@ -0,0 +1,1237 @@
+/*
+    libparted - a library for manipulating disk partitions
+    Copyright (C) 1999 - 2005 Free Software Foundation, Inc.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+*/
+
+#include "config.h"
+
+#include <parted/parted.h>
+#include <parted/debug.h>
+#include <parted/unit.h>
+
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <paths.h>
+#include <libgeom.h>
+#include <sys/param.h>
+#include <sys/ucred.h>
+#include <sys/mount.h>
+#include <sys/ioctl.h>
+#include <sys/sysctl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/disk.h>
+#include <sys/ata.h>
+
+#if ENABLE_NLS
+#  include <libintl.h>
+#  define _(String) dgettext (PACKAGE, String)
+#else
+#  define _(String) (String)
+#endif /* ENABLE_NLS */
+
+#include "../architecture.h"
+
+#if !defined(__FreeBSD_version) && defined(__FreeBSD_kernel_version)
+#define __FreeBSD_version __FreeBSD_kernel_version
+#endif
+
+#define FREEBSD_SPECIFIC(dev)	((FreeBSDSpecific*) (dev)->arch_specific)
+
+typedef	struct _FreeBSDSpecific	FreeBSDSpecific;
+
+struct _FreeBSDSpecific {
+#if (__FreeBSD_version >= 500000) && (__FreeBSD_version < 600000)
+	unsigned char channel;
+	unsigned char device;
+#endif
+	int	fd;
+};
+
+static char* _device_get_part_path (PedDevice* dev, int num);
+static int _partition_is_mounted_by_path (const char* path);
+
+static int
+_device_stat (PedDevice* dev, struct stat * dev_stat)
+{
+	PED_ASSERT (dev != NULL, return 0);
+	PED_ASSERT (!dev->external_mode, return 0);
+
+	while (1) {
+		if (!stat (dev->path, dev_stat)) {
+			return 1;
+		} else {
+			if (ped_exception_throw (
+				PED_EXCEPTION_ERROR,
+				PED_EXCEPTION_RETRY_CANCEL,
+				_("Could not stat device %s - %s."),
+				dev->path,
+				strerror (errno))
+					!= PED_EXCEPTION_RETRY)
+				return 0;
+		}
+	}
+}
+
+static int
+_device_probe_type (PedDevice* dev)
+{
+	struct stat		dev_stat;
+	char *np;
+	PedExceptionOption	ex_status;
+
+#if (__FreeBSD_version >= 500000) && (__FreeBSD_version < 600000)
+	FreeBSDSpecific*	arch_specific = FREEBSD_SPECIFIC (dev);
+#endif
+
+	if (!_device_stat (dev, &dev_stat))
+		return 0;
+
+	if (!S_ISCHR(dev_stat.st_mode)) {
+		dev->type = PED_DEVICE_FILE;
+		return 1;
+	}
+
+	/* On FreeBSD ad0 ist the ATA device */
+	np = strrchr(dev->path, '/');
+	if(np == NULL)
+	{
+		dev->type = PED_DEVICE_UNKNOWN;
+		return 0;
+	}
+	np += 1; /* advance past '/' */
+
+	if(strncmp(np, "ad", 2) == 0)
+	{
+		dev->type = PED_DEVICE_IDE;
+
+		/* ad0 -> channel 0, master
+		 * ad1 -> channel 0, slave
+		 * ad2 -> channel 1, master
+		 * ad3 -> channel 1, slave
+		 */
+#if (__FreeBSD_version >= 500000) && (__FreeBSD_version < 600000)
+		switch(*(np+3))
+		{
+		case 0:
+			arch_specific->channel = 0;
+			arch_specific->device = 0;
+			break;
+		case 1:
+			arch_specific->channel = 0;
+			arch_specific->device = 1;
+			break;
+		case 2:
+			arch_specific->channel = 1;
+			arch_specific->device = 0;
+			break;
+		case 4:
+			arch_specific->channel = 1;
+			arch_specific->device = 1;
+			break;
+		}
+#endif
+
+	}
+	else
+	{
+		dev->type = PED_DEVICE_UNKNOWN;
+	}
+
+	return 1;
+}
+
+static int
+_device_get_sector_size (PedDevice* dev)
+{
+	FreeBSDSpecific*	arch_specific = FREEBSD_SPECIFIC (dev);
+	u_int sector_size = PED_SECTOR_SIZE_DEFAULT; /*makes Valgrind happy*/
+
+	PED_ASSERT (dev->open_count, return 0);
+
+	if (ioctl (arch_specific->fd, DIOCGSECTORSIZE, &sector_size) == -1)
+		return PED_SECTOR_SIZE_DEFAULT;
+
+	if (sector_size != PED_SECTOR_SIZE_DEFAULT) {
+		if (ped_exception_throw (
+			PED_EXCEPTION_BUG,
+			PED_EXCEPTION_IGNORE_CANCEL,
+			_("The sector size on %s is %d bytes.  Parted is known "
+			"not to work properly with drives with sector sizes "
+			"other than %d bytes."),
+			dev->path,
+			sector_size,
+			PED_SECTOR_SIZE_DEFAULT)
+				== PED_EXCEPTION_IGNORE)
+			return sector_size;
+		else
+			return PED_SECTOR_SIZE_DEFAULT;
+	}
+
+	return sector_size;
+}
+
+static PedSector
+_device_get_length (PedDevice* dev)
+{
+	FreeBSDSpecific* arch_specific = FREEBSD_SPECIFIC (dev);
+	off_t bytes = 0;
+
+	PED_ASSERT (dev->open_count > 0, return 0);
+
+	if(ioctl(arch_specific->fd, DIOCGMEDIASIZE, &bytes) == 0) {
+		return bytes / PED_SECTOR_SIZE_DEFAULT;
+	}
+
+	return 0;
+}
+
+
+#if (__FreeBSD_version >= 500000) && (__FreeBSD_version < 600000)
+# define freebsd_get_ata_params freebsd_get_ata_params_compat5
+#elif (__FreeBSD_version >= 600000)
+# define freebsd_get_ata_params freebsd_get_ata_params_compat6
+#else
+# error "parted currently compiles on FreeBSD 5.X and 6.X only"
+#endif
+
+#if (__FreeBSD_version >= 500000) && (__FreeBSD_version < 600000)
+
+static int freebsd_get_ata_params_compat5(PedDevice *dev,
+										  struct ata_params *ap)
+{
+	struct ata_cmd iocmd;
+	int fd, ret;
+	FreeBSDSpecific*		arch_specific = FREEBSD_SPECIFIC (dev);
+
+	if ((fd = open("/dev/ata", O_RDWR)) == -1)
+	{
+		ped_exception_throw (
+			PED_EXCEPTION_ERROR,
+			PED_EXCEPTION_CANCEL,
+			_("Could not get open /dev/ata."));
+
+		ret = -1;
+		goto out;
+	}
+
+	bzero(&iocmd, sizeof(struct ata_cmd));
+	iocmd.channel = arch_specific->channel;
+	iocmd.device = arch_specific->device;
+	iocmd.cmd = ATAGPARM;
+
+	if (ioctl(fd, IOCATA, &iocmd) == -1)
+	{
+		ped_exception_throw (
+			PED_EXCEPTION_ERROR,
+			PED_EXCEPTION_CANCEL,
+			_("Could not get ATA parameters. Please"
+			  "contact the maintainer."));
+
+		ret = -1;
+		goto out;
+	}
+
+	if (iocmd.u.param.type[arch_specific->device]) {
+		*ap = iocmd.u.param.params[arch_specific->device];
+	} else
+	{
+		ped_exception_throw (
+			PED_EXCEPTION_ERROR,
+			PED_EXCEPTION_CANCEL,
+			_("Could not get ATA parameters. Please"
+			  "contact the maintainer."));
+		ret = -1;
+		goto out;
+	}
+
+	ret = 0;
+
+out:
+	close(fd);
+
+	return ret;
+}
+
+#elif __FreeBSD_version >= 600000
+
+static int freebsd_get_ata_params_compat6(PedDevice *dev,
+										  struct ata_params *ap)
+{
+	FreeBSDSpecific*		arch_specific = FREEBSD_SPECIFIC (dev);
+
+	return ioctl (arch_specific->fd, IOCATAGPARM, &ap);
+}
+
+#endif
+
+static int
+_device_probe_geometry (PedDevice* dev)
+{
+	FreeBSDSpecific*		arch_specific = FREEBSD_SPECIFIC (dev);
+	struct stat		dev_stat;
+	struct ata_params ap;
+
+	if (!_device_stat (dev, &dev_stat))
+		return 0;
+	PED_ASSERT (S_ISCHR (dev_stat.st_mode), return 0);
+
+	dev->length = _device_get_length (dev);
+	if (!dev->length)
+		return 0;
+
+	dev->sector_size = _device_get_sector_size (dev);
+	if (!dev->sector_size)
+		return 0;
+
+	dev->bios_geom.sectors = 63;
+	dev->bios_geom.heads = 255;
+	dev->bios_geom.cylinders
+	       	= dev->length / (63 * 255)
+	       		/ (dev->sector_size / PED_SECTOR_SIZE_DEFAULT);
+
+	if (freebsd_get_ata_params (dev, &ap) == 0) {
+		dev->hw_geom.sectors = ap.sectors;
+		dev->hw_geom.heads = ap.heads;
+		dev->hw_geom.cylinders = ap.cylinders;
+	} else {
+		dev->hw_geom = dev->bios_geom;
+	}
+
+	return 1;
+}
+
+static char*
+strip_name(char* str)
+{
+	int	i;
+	int	end = 0;
+
+	for (i = 0; str[i] != 0; i++) {
+		if (!isspace (str[i])
+		    || (isspace (str[i]) && !isspace (str[i+1]) && str[i+1])) {
+			str [end] = str[i];
+			end++;
+		}
+	}
+	str[end] = 0;
+	return strdup (str);
+}
+
+static int
+init_ide (PedDevice* dev)
+{
+	FreeBSDSpecific* arch_specific = FREEBSD_SPECIFIC(dev);
+	struct stat	dev_stat;
+	struct ata_params ap;
+	PedExceptionOption ex_status;
+	char vendor_buf[64];
+
+	if (!_device_stat (dev, &dev_stat))
+		goto error;
+
+	if (!ped_device_open (dev))
+		goto error;
+
+	if (freebsd_get_ata_params (dev, &ap) == -1) {
+		ex_status = ped_exception_throw (
+			PED_EXCEPTION_WARNING,
+			PED_EXCEPTION_IGNORE_CANCEL,
+			_("Could not get identity of device %s - %s"),
+			dev->path, strerror (errno));
+		switch (ex_status) {
+		case PED_EXCEPTION_CANCEL:
+			goto error_close_dev;
+
+		case PED_EXCEPTION_UNHANDLED:
+			ped_exception_catch ();
+		case PED_EXCEPTION_IGNORE:
+			dev->model = strdup(_("IDE"));
+		}
+	} else {
+		snprintf(vendor_buf, 64, "%.40s/%.8s", ap.model, ap.revision);
+		dev->model = strip_name (vendor_buf);
+	}
+
+	if (!_device_probe_geometry (dev))
+		goto error_close_dev;
+
+	ped_device_close (dev);
+	return 1;
+
+error_close_dev:
+	ped_device_close (dev);
+error:
+	return 0;
+}
+
+static int
+init_file (PedDevice* dev)
+{
+	struct stat	dev_stat;
+
+	if (!_device_stat (dev, &dev_stat))
+		goto error;
+	if (!ped_device_open (dev))
+		goto error;
+
+	if (S_ISCHR(dev_stat.st_mode))
+		dev->length = _device_get_length (dev);
+	else
+		dev->length = dev_stat.st_size / 512;
+	if (dev->length <= 0) {
+		ped_exception_throw (
+			PED_EXCEPTION_ERROR,
+			PED_EXCEPTION_CANCEL,
+			_("The device %s is zero-length, and can't possibly "
+			  "store a file system or partition table.  Perhaps "
+			  "you selected the wrong device?"),
+			dev->path);
+		goto error_close_dev;
+	}
+
+	ped_device_close (dev);
+
+	dev->bios_geom.cylinders = dev->length / 4 / 32;
+	dev->bios_geom.heads = 4;
+	dev->bios_geom.sectors = 32;
+	dev->hw_geom = dev->bios_geom;
+	dev->sector_size = 512;
+	dev->model = strdup ("");
+	return 1;
+
+error_close_dev:
+	ped_device_close (dev);
+error:
+	return 0;
+}
+
+static int
+init_generic (PedDevice* dev, char* model_name)
+{
+	struct stat		dev_stat;
+	PedExceptionOption	ex_status;
+
+	if (!_device_stat (dev, &dev_stat))
+		goto error;
+
+	if (!ped_device_open (dev))
+		goto error;
+
+	ped_exception_fetch_all ();
+	if (_device_probe_geometry (dev)) {
+		ped_exception_leave_all ();
+	} else {
+		/* hack to allow use of files, for testing */
+		ped_exception_catch ();
+		ped_exception_leave_all ();
+
+		ex_status = ped_exception_throw (
+				PED_EXCEPTION_WARNING,
+				PED_EXCEPTION_IGNORE_CANCEL,
+				_("Unable to determine geometry of "
+				"file/device.  You should not use Parted "
+				"unless you REALLY know what you're doing!"));
+		switch (ex_status) {
+			case PED_EXCEPTION_CANCEL:
+				goto error_close_dev;
+
+			case PED_EXCEPTION_UNHANDLED:
+				ped_exception_catch ();
+			case PED_EXCEPTION_IGNORE:
+				; // just workaround for gcc 3.0
+		}
+
+		/* what should we stick in here? */
+		dev->length = dev_stat.st_size / PED_SECTOR_SIZE_DEFAULT;
+		dev->bios_geom.cylinders = dev->length / 4 / 32;
+		dev->bios_geom.heads = 4;
+		dev->bios_geom.sectors = 32;
+		dev->sector_size = PED_SECTOR_SIZE_DEFAULT;
+	}
+
+	dev->model = strdup (model_name);
+
+	ped_device_close (dev);
+	return 1;
+
+error_close_dev:
+	ped_device_close (dev);
+error:
+	return 0;
+}
+
+static PedDevice*
+freebsd_new (const char* path)
+{
+	PedDevice*	dev;
+
+	PED_ASSERT (path != NULL, return NULL);
+
+	dev = (PedDevice*) ped_malloc (sizeof (PedDevice));
+	if (!dev)
+		goto error;
+
+	dev->path = strdup (path);
+	if (!dev->path)
+		goto error_free_dev;
+
+	dev->arch_specific
+		= (FreeBSDSpecific*) ped_malloc (sizeof (FreeBSDSpecific));
+	if (!dev->arch_specific)
+		goto error_free_path;
+
+	dev->open_count = 0;
+	dev->read_only = 0;
+	dev->external_mode = 0;
+	dev->dirty = 0;
+	dev->boot_dirty = 0;
+
+	if (!_device_probe_type (dev))
+		goto error_free_arch_specific;
+
+	switch (dev->type) {
+	case PED_DEVICE_IDE:
+		if (!init_ide (dev))
+			goto error_free_arch_specific;
+		break;
+
+	case PED_DEVICE_FILE:
+		if (!init_file (dev))
+			goto error_free_arch_specific;
+		break;
+
+	default:
+		ped_exception_throw (PED_EXCEPTION_NO_FEATURE,
+				PED_EXCEPTION_CANCEL,
+				_("ped_device_new()  Unsupported device type"));
+		goto error_free_arch_specific;
+	}
+	return dev;
+
+error_free_arch_specific:
+	free (dev->arch_specific);
+error_free_path:
+	free (dev->path);
+error_free_dev:
+	free (dev);
+error:
+	return NULL;
+}
+
+static void
+freebsd_destroy (PedDevice* dev)
+{
+	free (dev->arch_specific);
+	free (dev->path);
+	free (dev->model);
+	free (dev);
+}
+
+static int
+freebsd_is_busy (PedDevice* dev)
+{
+	int	i;
+	char*	part_name;
+
+	if (_partition_is_mounted_by_path (dev->path))
+		return 1;
+
+	for (i = 0; i < 32; i++) {
+		int status;
+
+		part_name = _device_get_part_path (dev, i);
+		if (!part_name)
+			return 1;
+		status = _partition_is_mounted_by_path (part_name);
+		free (part_name);
+
+		if (status)
+			return 1;
+	}
+
+	return 0;
+}
+
+#if (__FreeBSD_version >= 500000) && (__FreeBSD_version < 600000)
+# define _flush_cache freebsd_flush_cache_compat5
+#elif (__FreeBSD_version >= 600000)
+# define _flush_cache freebsd_flush_cache_compat6
+#else
+# error "parted currently compiles on FreeBSD 5.X and 6.X only"
+#endif
+
+#if (__FreeBSD_version >= 500000) && (__FreeBSD_version < 600000)
+
+static void
+freebsd_flush_cache_compat5 (PedDevice* dev)
+{
+	FreeBSDSpecific*	arch_specific = FREEBSD_SPECIFIC (dev);
+	int fd;
+	struct ata_cmd iocmd;
+
+	if (dev->type != PED_DEVICE_IDE)
+		return;
+
+	if (freebsd_is_busy(dev))
+		printf("FreeBSD: Device %s is mounted. Not flushing cache.\n",
+			   dev->path);
+
+	if ((fd = open("/dev/ata", O_RDWR)) == -1)
+	{
+		ped_exception_throw (
+			PED_EXCEPTION_ERROR,
+			PED_EXCEPTION_CANCEL,
+			_("Could not open /dev/ata."));
+
+		goto out;
+	}
+
+	if (dev->read_only)
+		goto out;
+	dev->dirty = 0;
+
+	bzero(&iocmd, sizeof(struct ata_cmd));
+	iocmd.channel = arch_specific->channel;
+	iocmd.device = arch_specific->device;
+	iocmd.cmd = ATAREQUEST;
+	iocmd.u.request.u.ata.command = ATA_FLUSHCACHE;
+
+	if (ioctl(fd, IOCATA, &iocmd) == -1)
+	{
+		ped_exception_throw (
+			PED_EXCEPTION_ERROR,
+			PED_EXCEPTION_CANCEL,
+			_("Could not flush cache."));
+
+		goto out;
+	}
+
+out:
+	close (fd);
+
+	return;
+}
+
+#elif __FreeBSD_version >= 600000
+
+static void
+freebsd_flush_cache_compat6 (PedDevice* dev)
+{
+	FreeBSDSpecific*	arch_specific = FREEBSD_SPECIFIC (dev);
+	struct ata_ioc_request ioreq;
+
+	if (dev->type != PED_DEVICE_IDE)
+		return;
+
+	if (freebsd_is_busy(dev))
+		printf("FreeBSD: Device %s is mounted. Not flushing cache.\n",
+			   dev->path);
+
+	if (dev->read_only)
+		return;
+	dev->dirty = 0;
+
+	bzero(&ioreq, sizeof(struct ata_ioc_request));
+	ioreq.u.ata.command = ATA_FLUSHCACHE;
+
+	if (ioctl(arch_specific->fd, IOCATAREQUEST, &ioreq) == -1)
+	{
+		ped_exception_throw (
+			PED_EXCEPTION_ERROR,
+			PED_EXCEPTION_CANCEL,
+			_("Could not flush cache."));
+		return;
+	}
+
+	return;
+}
+
+#endif
+
+/* By default, kernel of FreeBSD does not allow overwriting MBR */
+#define GEOM_SYSCTL    "kern.geom.debugflags"
+
+static int
+freebsd_open (PedDevice* dev)
+{
+	int old_flags, flags;
+	size_t sizeof_int = sizeof (int);
+	FreeBSDSpecific*	arch_specific = FREEBSD_SPECIFIC (dev);
+
+retry:
+	if (sysctlbyname (GEOM_SYSCTL, &old_flags, &sizeof_int, NULL, 0) != 0)
+		ped_exception_throw (PED_EXCEPTION_WARNING, PED_EXCEPTION_OK,
+							 _("Unable to get %s sysctl (%s)."), GEOM_SYSCTL,
+							 strerror (errno));
+
+	if ((old_flags & 0x10) == 0)
+	{
+		/* "allow foot shooting", see geom(4) */
+		flags = old_flags | 0x10;
+
+		if (sysctlbyname (GEOM_SYSCTL, NULL, NULL, &flags, sizeof (int)) != 0)
+		{
+			flags = old_flags;
+			ped_exception_throw (PED_EXCEPTION_WARNING, PED_EXCEPTION_OK,
+								 _("Unable to set %s sysctl (%s)."), GEOM_SYSCTL,
+								 strerror (errno));
+		}
+	}
+	else
+		flags = old_flags;
+
+	arch_specific->fd = open (dev->path, O_RDWR);
+
+	if (flags != old_flags)
+	{
+		if (sysctlbyname (GEOM_SYSCTL, NULL, NULL, &old_flags, sizeof (int)) != 0)
+			ped_exception_throw (PED_EXCEPTION_WARNING, PED_EXCEPTION_OK,
+								 _("Unable to set %s sysctl (%s)."), GEOM_SYSCTL,
+								 strerror (errno));
+	}
+
+	if (arch_specific->fd == -1) {
+		char*	rw_error_msg = strerror (errno);
+
+		arch_specific->fd = open (dev->path, O_RDONLY);
+		if (arch_specific->fd == -1) {
+			if (ped_exception_throw (
+				PED_EXCEPTION_ERROR,
+				PED_EXCEPTION_RETRY_CANCEL,
+				_("Error opening %s: %s"),
+				dev->path, strerror (errno))
+					!= PED_EXCEPTION_RETRY) {
+				return 0;
+			} else {
+				goto retry;
+			}
+		} else {
+			ped_exception_throw (
+				PED_EXCEPTION_WARNING,
+				PED_EXCEPTION_OK,
+				_("Unable to open %s read-write (%s).  %s has "
+				  "been opened read-only."),
+				dev->path, rw_error_msg, dev->path);
+			dev->read_only = 1;
+		}
+	} else {
+		dev->read_only = 0;
+	}
+
+	_flush_cache (dev);
+
+	return 1;
+}
+
+static int
+freebsd_refresh_open (PedDevice* dev)
+{
+	return 1;
+}
+
+static int
+freebsd_close (PedDevice* dev)
+{
+	FreeBSDSpecific*		arch_specific = FREEBSD_SPECIFIC (dev);
+
+	if (dev->dirty)
+		_flush_cache (dev);
+	close (arch_specific->fd);
+	return 1;
+}
+
+static int
+freebsd_refresh_close (PedDevice* dev)
+{
+	if (dev->dirty)
+		_flush_cache (dev);
+	return 1;
+}
+
+static int
+_device_seek (const PedDevice* dev, PedSector sector)
+{
+	FreeBSDSpecific*	arch_specific;
+	off_t	pos;
+
+	PED_ASSERT (dev != NULL, return 0);
+	PED_ASSERT (!dev->external_mode, return 0);
+
+	arch_specific = FREEBSD_SPECIFIC (dev);
+
+	pos = sector * PED_SECTOR_SIZE_DEFAULT;
+	return lseek (arch_specific->fd, pos, SEEK_SET) == pos;
+}
+
+static int
+freebsd_read (const PedDevice* dev, void* buffer, PedSector start, PedSector count)
+{
+	FreeBSDSpecific*		arch_specific = FREEBSD_SPECIFIC (dev);
+	int			status;
+	PedExceptionOption	ex_status;
+	size_t			read_length = count * PED_SECTOR_SIZE_DEFAULT;
+
+	while (1) {
+		if (_device_seek (dev, start))
+			break;
+
+		ex_status = ped_exception_throw (
+			PED_EXCEPTION_ERROR,
+			PED_EXCEPTION_RETRY_IGNORE_CANCEL,
+			_("%s during seek for read on %s"),
+			strerror (errno), dev->path);
+
+		switch (ex_status) {
+			case PED_EXCEPTION_IGNORE:
+				return 1;
+
+			case PED_EXCEPTION_RETRY:
+				break;
+
+			case PED_EXCEPTION_UNHANDLED:
+				ped_exception_catch ();
+			case PED_EXCEPTION_CANCEL:
+				return 0;
+		}
+	}
+
+	while (1) {
+		status = read (arch_specific->fd, buffer, read_length);
+		if (status == count * PED_SECTOR_SIZE_DEFAULT) break;
+		if (status > 0) {
+			read_length -= status;
+			buffer += status;
+			continue;
+		}
+
+		ex_status = ped_exception_throw (
+			PED_EXCEPTION_ERROR,
+			PED_EXCEPTION_RETRY_IGNORE_CANCEL,
+			_("%s during read on %s"),
+			strerror (errno),
+			dev->path);
+
+		switch (ex_status) {
+			case PED_EXCEPTION_IGNORE:
+				return 1;
+
+			case PED_EXCEPTION_RETRY:
+				break;
+
+			case PED_EXCEPTION_UNHANDLED:
+				ped_exception_catch ();
+			case PED_EXCEPTION_CANCEL:
+				return 0;
+		}
+	}
+
+	return 1;
+}
+
+static int
+freebsd_write (PedDevice* dev, const void* buffer, PedSector start,
+	     PedSector count)
+{
+	FreeBSDSpecific*		arch_specific = FREEBSD_SPECIFIC (dev);
+	int			status;
+	PedExceptionOption	ex_status;
+	size_t			write_length = count * PED_SECTOR_SIZE_DEFAULT;
+
+	if (dev->read_only) {
+		if (ped_exception_throw (
+			PED_EXCEPTION_ERROR,
+			PED_EXCEPTION_IGNORE_CANCEL,
+			_("Can't write to %s, because it is opened read-only."),
+			dev->path)
+				!= PED_EXCEPTION_IGNORE)
+			return 0;
+		else
+			return 1;
+	}
+
+	while (1) {
+		if (_device_seek (dev, start))
+			break;
+
+		ex_status = ped_exception_throw (
+			PED_EXCEPTION_ERROR, PED_EXCEPTION_RETRY_IGNORE_CANCEL,
+			_("%s during seek for write on %s"),
+			strerror (errno), dev->path);
+
+		switch (ex_status) {
+			case PED_EXCEPTION_IGNORE:
+				return 1;
+
+			case PED_EXCEPTION_RETRY:
+				break;
+
+			case PED_EXCEPTION_UNHANDLED:
+				ped_exception_catch ();
+			case PED_EXCEPTION_CANCEL:
+				return 0;
+		}
+	}
+
+#ifdef READ_ONLY
+	printf ("ped_device_write (\"%s\", %p, %d, %d)\n",
+		dev->path, buffer, (int) start, (int) count);
+#else
+	dev->dirty = 1;
+	while (1) {
+		status = write (arch_specific->fd, buffer, write_length);
+		if (status == count * PED_SECTOR_SIZE_DEFAULT) break;
+		if (status > 0) {
+			write_length -= status;
+			buffer += status;
+			continue;
+		}
+
+		ex_status = ped_exception_throw (
+			PED_EXCEPTION_ERROR,
+			PED_EXCEPTION_RETRY_IGNORE_CANCEL,
+			_("%s during write on %s"),
+			strerror (errno), dev->path);
+
+		switch (ex_status) {
+			case PED_EXCEPTION_IGNORE:
+				return 1;
+
+			case PED_EXCEPTION_RETRY:
+				break;
+
+			case PED_EXCEPTION_UNHANDLED:
+				ped_exception_catch ();
+			case PED_EXCEPTION_CANCEL:
+				return 0;
+		}
+	}
+#endif /* !READ_ONLY */
+	return 1;
+}
+
+/* returns the number of sectors that are ok.
+ */
+static PedSector
+freebsd_check (PedDevice* dev, void* buffer, PedSector start, PedSector count)
+{
+	FreeBSDSpecific*	arch_specific = FREEBSD_SPECIFIC (dev);
+	PedSector	done = 0;
+	int		status;
+
+	if (!_device_seek (dev, start))
+		return 0;
+
+	for (done = 0; done < count; done += status / PED_SECTOR_SIZE_DEFAULT) {
+		status = read (arch_specific->fd, buffer,
+			       (size_t) ((count-done) * PED_SECTOR_SIZE_DEFAULT));
+		if (status < 0)
+			break;
+	}
+
+	return done;
+}
+
+static int
+_do_fsync (PedDevice* dev)
+{
+	FreeBSDSpecific*		arch_specific = FREEBSD_SPECIFIC (dev);
+	int			status;
+	PedExceptionOption	ex_status;
+
+	while (1) {
+		status = fsync (arch_specific->fd);
+		if (status >= 0) break;
+
+		ex_status = ped_exception_throw (
+			PED_EXCEPTION_ERROR,
+			PED_EXCEPTION_RETRY_IGNORE_CANCEL,
+			_("%s during write on %s"),
+			strerror (errno), dev->path);
+
+		switch (ex_status) {
+			case PED_EXCEPTION_IGNORE:
+				return 1;
+
+			case PED_EXCEPTION_RETRY:
+				break;
+
+			case PED_EXCEPTION_UNHANDLED:
+				ped_exception_catch ();
+			case PED_EXCEPTION_CANCEL:
+				return 0;
+		}
+	}
+	return 1;
+}
+
+static int
+freebsd_sync (PedDevice* dev)
+{
+	PED_ASSERT (dev != NULL, return 0);
+	PED_ASSERT (!dev->external_mode, return 0);
+
+	if (dev->read_only)
+		return 1;
+	if (!_do_fsync (dev))
+		return 0;
+	_flush_cache (dev);
+	return 1;
+}
+
+static int
+freebsd_sync_fast (PedDevice* dev)
+{
+	PED_ASSERT (dev != NULL, return 0);
+	PED_ASSERT (!dev->external_mode, return 0);
+
+	if (dev->read_only)
+		return 1;
+	if (!_do_fsync (dev))
+		return 0;
+	/* no cache flush... */
+	return 1;
+}
+
+/* XXX code from /usr/src/lib/libdisk/disk.c */
+static int
+_probe_standard_devices ()
+{
+	char		dev_name [16];
+	char		dev_type [16];
+	char		fullpath [256];
+	int 		ret;
+	char*		conftxt;
+	char*		cptr;
+	size_t		txtsize;
+
+
+	ret = sysctlbyname("kern.geom.conftxt", NULL, &txtsize, NULL, 0);
+	if (ret) {
+		printf("kern.geom.conftxt sysctl not available, giving up!");
+		return 0;
+	}
+	conftxt = ped_malloc(txtsize+1);
+	if (conftxt == NULL) {
+		printf("cannot malloc memory for conftxt");
+		return 0;
+	}
+	ret = sysctlbyname("kern.geom.conftxt", conftxt, &txtsize, NULL, 0);
+	if (ret) {
+		printf("error reading kern.geom.conftxt from the system");
+		free (conftxt);
+		return 0;
+	}
+
+	cptr = conftxt;
+
+	while (sscanf (cptr, "%*d %s %s",
+				   dev_type, dev_name) != EOF) {
+		if (strcmp(dev_type, "DISK") == 0)
+		{
+			strcpy (fullpath, _PATH_DEV);
+			strcat (fullpath, dev_name);
+			printf("FreeBSD: probing %s...\n", fullpath);
+			_ped_device_probe (fullpath);
+		}
+
+		cptr = strchr(cptr, '\n');
+		if (!cptr)
+			break;
+		cptr++;
+	}
+
+	free(conftxt);
+
+	return 1;
+}
+
+static void
+freebsd_probe_all ()
+{
+	_probe_standard_devices ();
+}
+
+static char*
+_device_get_part_path (PedDevice* dev, int num)
+{
+	int		path_len = strlen (dev->path);
+	int		result_len = path_len + 16;
+	int		is_gpt;
+	char*		result;
+	PedDisk*	disk;
+
+	disk = ped_disk_new (dev);
+	if (!disk)
+		return NULL;
+
+	result = (char*) ped_malloc (result_len);
+	if (!result)
+		return NULL;
+
+	is_gpt = !strcmp (disk->type->name, "gpt");
+
+	ped_disk_destroy (disk);
+
+	/* append slice number (ad0, partition 1 => ad0s1)*/
+	snprintf (result, result_len, is_gpt ? "%sp%d" : "%ss%d", dev->path, num);
+
+	return result;
+}
+
+static char*
+freebsd_partition_get_path (const PedPartition* part)
+{
+	return _device_get_part_path (part->disk->dev, part->num);
+}
+
+/* XXX code from /usr/src/sbin/mount/mount.c:getmntpt() */
+static int
+_partition_is_mounted_by_path (const char *path)
+{
+	struct stat part_stat, mntdevstat;
+	struct statfs *mntbuf, *statfsp;
+	char *devname;
+	char device[256];
+	int mntsize, i;
+
+	if (stat (path, &part_stat) != 0)
+		return 0;
+
+	if (!S_ISCHR(part_stat.st_mode))
+		return 0;
+
+	mntsize = getmntinfo(&mntbuf, MNT_NOWAIT);
+	for (i = 0; i < mntsize; i++) {
+		statfsp = &mntbuf[i];
+		devname = statfsp->f_mntfromname;
+		if (*devname != '/') {
+			strcpy(device, _PATH_DEV);
+			strcat(device, devname);
+			strcpy(statfsp->f_mntfromname, device);
+		}
+		if (stat(devname, &mntdevstat) == 0 &&
+			mntdevstat.st_rdev == part_stat.st_rdev)
+			return 1;
+	}
+
+	return 0;
+}
+
+static int
+_partition_is_mounted (const PedPartition *part)
+{
+	dev_t dev;
+	if (!ped_partition_is_active (part))
+		return 0;
+
+	return _partition_is_mounted_by_path (part->disk->dev->path);
+}
+
+static int
+freebsd_partition_is_busy (const PedPartition* part)
+{
+	PedPartition*	walk;
+
+	PED_ASSERT (part != NULL, return 0);
+
+	if (_partition_is_mounted (part))
+		return 1;
+	if (part->type == PED_PARTITION_EXTENDED) {
+		for (walk = part->part_list; walk; walk = walk->next) {
+			if (freebsd_partition_is_busy (walk))
+				return 1;
+		}
+	}
+	return 0;
+}
+
+/* XXX maybe read the MBR again and hand it over to geom? */
+static int
+_kernel_reread_part_table (PedDevice* dev)
+{
+	FreeBSDSpecific*	arch_specific = FREEBSD_SPECIFIC (dev);
+	int		retry_count = 5;
+	struct gctl_req *grq;
+	char mbr_buf[512];
+	const char *q;
+
+	sync();
+
+	freebsd_read (dev, mbr_buf, 0, 1);
+
+	grq = gctl_get_handle();
+	gctl_ro_param(grq, "verb", -1, "write MBR");
+	gctl_ro_param(grq, "class", -1, "MBR");
+	q = strrchr(dev->path, '/');
+	if (q == NULL)
+		q = dev->path;
+	else
+		q++;
+	gctl_ro_param(grq, "geom", -1, q);
+	gctl_ro_param(grq, "data", dev->sector_size, mbr_buf);
+	q = gctl_issue(grq);
+	if (q == NULL) {
+		gctl_free(grq);
+		return(0);
+	}
+
+	gctl_free(grq);
+
+	return 1;
+}
+
+static int
+freebsd_disk_commit (PedDisk* disk)
+{
+	if (disk->dev->type != PED_DEVICE_FILE)
+		return _kernel_reread_part_table (disk->dev);
+
+	return 1;
+}
+
+static PedDeviceArchOps freebsd_dev_ops = {
+	_new:			freebsd_new,
+	destroy:		freebsd_destroy,
+	is_busy:		freebsd_is_busy,
+	open:			freebsd_open,
+	refresh_open:	freebsd_refresh_open,
+	close:			freebsd_close,
+	refresh_close:	freebsd_refresh_close,
+	read:			freebsd_read,
+	write:			freebsd_write,
+	check:			freebsd_check,
+	sync:			freebsd_sync,
+	sync_fast:		freebsd_sync_fast,
+	probe_all:		freebsd_probe_all
+};
+
+PedDiskArchOps freebsd_disk_ops =  {
+	partition_get_path:	freebsd_partition_get_path,
+	partition_is_busy:	freebsd_partition_is_busy,
+	disk_commit:		freebsd_disk_commit
+};
+
+PedArchitecture ped_freebsd_arch = {
+	dev_ops:	&freebsd_dev_ops,
+	disk_ops:	&freebsd_disk_ops
+};
Index: b/libparted/architecture.c
===================================================================
--- a/libparted/architecture.c
+++ b/libparted/architecture.c
@@ -34,6 +34,9 @@
 #elif defined(__BEOS__)
 	extern PedArchitecture ped_beos_arch;
 	const PedArchitecture* arch = &ped_beos_arch;
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+	extern PedArchitecture ped_freebsd_arch;
+	const PedArchitecture* arch = &ped_freebsd_arch;
 #else
 	extern PedArchitecture ped_gnu_arch;
 	const PedArchitecture* arch = &ped_gnu_arch;
Index: b/libparted/fs/xfs/platform_defs.h
===================================================================
--- a/libparted/fs/xfs/platform_defs.h
+++ b/libparted/fs/xfs/platform_defs.h
@@ -37,7 +37,11 @@
 #include <stdio.h>
 #include <stdarg.h>
 #include <assert.h>
-#include <endian.h>
+#if HAVE_ENDIAN_H
+# include <endian.h>
+#elif HAVE_SYS_ENDIAN_H
+# include <sys/endian.h>
+#endif
 #include <stddef.h>
 #include <stdlib.h>
 #include <string.h>
Index: b/libparted/labels/bsd.c
===================================================================
--- a/libparted/labels/bsd.c
+++ b/libparted/labels/bsd.c
@@ -26,6 +26,7 @@
 #include <parted/debug.h>
 #include <parted/endian.h>
 #include <stdbool.h>
+#include <sys/types.h>
 
 #if ENABLE_NLS
 #  include <libintl.h>
Index: b/libparted/labels/sun.c
===================================================================
--- a/libparted/labels/sun.c
+++ b/libparted/labels/sun.c
@@ -26,6 +26,7 @@
 #include <parted/debug.h>
 #include <parted/endian.h>
 #include <stdbool.h>
+#include <sys/types.h>
 
 #if ENABLE_NLS
 #  include <libintl.h>
